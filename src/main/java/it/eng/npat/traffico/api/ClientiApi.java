/**
 * NOTE: This class is auto generated by the swagger code generator program (3.0.2-SNAPSHOT).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package it.eng.npat.traffico.api;

import java.math.BigDecimal;

import it.eng.npat.traffico.logic.DettaglioTrafficoLogic;
import it.eng.npat.traffico.model.ErrorMessage;

import java.time.LocalDate;

import it.eng.npat.traffico.model.ReportTrafficoBean;

import com.fasterxml.jackson.databind.ObjectMapper;

import io.swagger.annotations.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.format.annotation.DateTimeFormat.ISO;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import javax.validation.constraints.*;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Optional;
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.SpringCodegen", date = "2018-10-08T17:21:54.417Z[Etc/UTC]")

@Api(value = "clienti", description = "the clienti API")
public interface ClientiApi {

    Logger log = LoggerFactory.getLogger(ClientiApi.class);

    default Optional<ObjectMapper> getObjectMapper() {
        return Optional.empty();
    }

    default Optional<HttpServletRequest> getRequest() {
        return Optional.empty();
    }

    default Optional<String> getAcceptHeader() {
        return getRequest().map(r -> r.getHeader("Accept"));
    }

    @ApiOperation(value = "", nickname = "clientiConsistenzeNumLineaDettaglioTrafficoGet", notes = "Servizio che consente di recuperare un oggetto di tipo `traffico`.", response = ReportTrafficoBean.class, responseContainer = "List", tags={ "ID 211", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Risposta di successo", response = ReportTrafficoBean.class, responseContainer = "List"),
        @ApiResponse(code = 400, message = "Richiesta errata. Il dato passato in input non è formattato correttamente e non può essere elaborato. ", response = ErrorMessage.class),
        @ApiResponse(code = 401, message = "La richiesta richiede un'autenticazione dell’utente.", response = ErrorMessage.class),
        @ApiResponse(code = 403, message = "Accesso non è consentito, l’utente non dispone dei diritti per accedere alla risorsa. ", response = ErrorMessage.class),
        @ApiResponse(code = 404, message = "Risorsa non trovata.", response = ErrorMessage.class),
        @ApiResponse(code = 408, message = "Richiesta scaduta. L’esecuzione del metodo non è terminata nei tempi stabiliti.  ", response = ErrorMessage.class),
        @ApiResponse(code = 422, message = "Richiesta non processabile (caso tipico perchè i dati inseriti sono sintatticamente esatti ma semanticamente non corretti).", response = ErrorMessage.class),
        @ApiResponse(code = 500, message = "Errore generico non è stato possibile portare a termine l’esecuzione del metodo.", response = ErrorMessage.class),
        @ApiResponse(code = 503, message = "Servizio non disponibile.", response = ErrorMessage.class),
        @ApiResponse(code = 504, message = "Gateway timeout.", response = ErrorMessage.class) })
    @RequestMapping(value = "/clienti/consistenze/{numLinea}/dettaglioTraffico",
        produces = { "application/json" }, 
        method = RequestMethod.GET)
    default ResponseEntity<List<ReportTrafficoBean>> clientiConsistenzeNumLineaDettaglioTrafficoGet(
    		@ApiParam(value = "numero di linea del cliente",required=true) @PathVariable("numLinea") String numLinea,
    		@NotNull @ApiParam(value = "Identifica la macro tipologia di traffico che si vuole visualizzare.", required = true) @Valid @RequestParam(value = "macroFamiglia", required = true) String macroFamiglia,
    		@NotNull @ApiParam(value = "periodo inizio di riferimento richiesto", required = true) @Valid @RequestParam(value = "dataInizio", required = true) @DateTimeFormat(pattern = "dd-MM-yyyy") LocalDate dataInizio,
    		@NotNull @ApiParam(value = "periodo fine di riferimento richiesto", required = true) @Valid @RequestParam(value = "dataFine", required = true) @DateTimeFormat(iso = ISO.DATE) LocalDate dataFine,
    		@NotNull @ApiParam(value = "Permette di recuperare il traffico a costo", required = true) @Valid @RequestParam(value = "costo", required = true) String costo,
    		@ApiParam(value = "Nome di chi origina la chiamata (es. Channel Backend, SDP, CRM). Il valore viene aggiornato ad ogni passaggio inserendo il proprio identificativo. Viene aggiornata ad ogni passaggio tra sistemi." ,required=true) @RequestHeader(value="sourceSystem", required=true) String sourceSystem,
    		@ApiParam(value = "Identificativo canale digitale che ha generato inizialmente la chiamate (es. WEB, APP). L’informazione è passante e immutabile tra i vari sistemi." ,required=true) @RequestHeader(value="channel", required=true) String channel,
    		@ApiParam(value = "E’ la data di quando l’utente ha effettuato l’interazione con il canale. Formato: YYYY-MM-DD" ,required=true) @RequestHeader(value="interactionDate-Date", required=true) @DateTimeFormat(iso = ISO.DATE) LocalDate interactionDateDate,
    		@ApiParam(value = "E’ l’ora di quando l’utente ha effettuato l’interazione con il canale. Formato: hh:mm:ss.SSS" ,required=true) @RequestHeader(value="interactionDate-Time", required=true) String interactionDateTime,
    		@ApiParam(value = "ID di Sessione del canale digitale. Identificativo di una sessione di lavoro aperta da un utente o processo applicativo (WEB)" ,required=true) @RequestHeader(value="sessionID", required=true) String sessionID,
    		@ApiParam(value = "Identificativo univoco di un intero processo di business, costituito da un insieme di operazioni elementari che portano i partecipanti, in un’architettura distribuita, da uno stato globalmente consistente a un altro. Dal punto di vista di un osservatore esterno all’intera organizzazione (utente del processo), l’intera esecuzione è atomica, pur ammettendo stati interni localmente consistenti e non osservabili dall’esterno." ,required=true) @RequestHeader(value="businessID", required=true) String businessID,
    		@ApiParam(value = "Identificativo univoco della singola transazione che coinvolge due partecipanti. Dal punto di vista di un osservatore esterno al dominio che include i soli partecipanti alla transazione, l’intera esecuzione è atomica, pur ammettendo stati interni localmente consistenti e non osservabili dall’esterno del dominio. Il termine transazione, nel contesto considerato di una architettura a servizi, va inteso in senso lato, includendo lo scambio di messaggi asincroni, correlati, atti a modificare lo stato del sistema." ,required=true) @RequestHeader(value="transactionID", required=true) String transactionID,
    		@ApiParam(value = "Descrive la tipologia di traffico richiesta") @Valid @RequestParam(value = "tipoChiamata", required = false) List<String> tipoChiamata,
    		@ApiParam(value = "Valorizzare coi campi da tornare,  o non passare per tornarli tutti.") @Valid @RequestParam(value = "fields", required = false) List<String> fields,@ApiParam(value = "Numero di pagina del result set che si vuole ottenere in risposta. Nel caso in cui non venga specificato tale valore verrà riportata la prima pagina") @Valid @RequestParam(value = "pageNumber", required = false) BigDecimal pageNumber,
    		@ApiParam(value = "Numero di risultati riportati sulla singola pagina. Nel caso in cui non venga specificato tale valore verrà impostato ad un valore di default configurabile sul microservizio (a livello di back end). Tale valore presuppone un limite configurabile a livello di microservizio. (Se viene ecceduto tale limite si restituisce un error code 400)") @Valid @RequestParam(value = "pageSize", required = false) BigDecimal pageSize,
    		@ApiParam(value = "Parametro sul quale si intende effettuare l'ordinamento dei risultati") @Valid @RequestParam(value = "orderField", required = false) String orderField,
    		@ApiParam(value = "Direzione dell'ordinamento (ascendente, discendente)") @Valid @RequestParam(value = "order", required = false) String order,
    		@ApiParam(value = "Identificativo univoco del singolo messaggio inviato su un canale di comunicazione." ) @RequestHeader(value="messageID", required=false) String messageID,
    		@ApiParam(value = "Informazione generata e arricchita da APIGW. Non obbligatoria per i canali digitali." ) @RequestHeader(value="APIGW_requestID", required=false) String apIGWRequestID,
    		@ApiParam(value = "Campo opzionale che indica che il messaggio è stato ri-sottomesso. Se presente è valorizzato come true." , allowableValues="true") @RequestHeader(value="resubmitted", required=false) String resubmitted) {
        if(getObjectMapper().isPresent() && getAcceptHeader().isPresent()) {
        } else {
            log.warn("ObjectMapper or HttpServletRequest not configured in default ClientiApi interface so no example is generated");
        }
        DettaglioTrafficoLogic logic=new DettaglioTrafficoLogic();
        List<ReportTrafficoBean> res = logic.getTraffico(numLinea, macroFamiglia, dataInizio, dataFine, costo);
        
        ResponseEntity<List<ReportTrafficoBean>> re = new ResponseEntity<List<ReportTrafficoBean>>(res,HttpStatus.OK);
        return re;
        //return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);
    }

}
